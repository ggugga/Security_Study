원격 코드 실행(Remote Code Execution) 취약점 
- 공격을 어렵게 하기 위한 보안 매커니즘인 샌드박스(Sandbox)
- 샌드박스(Sandbox)에 속하는 기술인 SECCOMP
- SECCOMP이 적용된 바이너리의 분석을 도와주는 도구인 seccomp-tools

# 샌드박스(Sandbox)
= 외부의 공격으로부터 시스템을 보호하기 위해 설계된 기법
= 애플리케이션의 기능을 수행하는데 꼭 필요한 시스템 콜 실행, 파일의 접근만을 허용
- Allow List와 Deny List 두 가지를 선택해 적용

# SECure COMPuting mode (SECCOMP) 
= 리눅스 커널에서 프로그램의 샌드박싱 매커니즘을 제공하는 보안 기능
= 애플리케이션에서 불필요한 시스템 콜의 호출을 방지
- STRICT_MODE 와 FILTER_MODE 두 가지의 모드를 선택해서 적용 가능

외부의 시스템 명령어를 실행하지 않는다면?
-> execve와 같은 시스템 콜이 굳이 실행될 필요가 없음
즉, 외부의 공격으로부터 execve시스템 콜이 실행될 경우 애플리케이션을 즉시 종료
-> 애플리케이션의 취약점이 존재해도 외부의 공격으로부터 피해를 최소화 가능

## STRICT_MODE
= read , write , exit , sigreturn  시스템 콜의 호출만을 허용
= 이외의 시스템 콜의 호출 요청시 SIGKILL 시그널을 발생하고 프로그램을 종료
- 다양한 기능을 수행하는 애플리케이션에서 적용 불가
```
// Name: strict_mode.c
// Compile: gcc -o strict_mode strict_mode.c
#include <fcntl.h>
#include <linux/seccomp.h>
#include <sys/prctl.h>
#include <unistd.h>
void init_filter() { prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT); }
int main() {
  char buf[256];
  int fd = 0;
  init_filter();
  write(1, "OPEN!\n", 6);
  fd = open("/bin/sh", O_RDONLY);
  write(1, "READ!\n", 6);
  read(fd, buf, sizeof(buf) - 1);
  write(1, buf, sizeof(buf));
  return 0;
}
```
코드 내에서  init_filter 함수에서 prctl 함수를 사용해 해당 모드를 적용한 것을 볼 수 있습니다
`void init_filter() { prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT); }`
즉, 해당 코드를 실행 결과
```
$ ./strict_mode
OPEN!
Killed
```
open 함수가 실행되지 않고 프로그램이 종료되는 것을 확인할 수 있습니다.

## STRICT_MODE 동작 원리

```
static const int mode1_syscalls[] = {
    __NR_seccomp_read,
    __NR_seccomp_write,
    __NR_seccomp_exit,
    __NR_seccomp_sigreturn,
    -1, /* negative terminated */
};
```

```
#ifdef CONFIG_COMPAT
static int mode1_syscalls_32[] = {
    __NR_seccomp_read_32,
    __NR_seccomp_write_32,
    __NR_seccomp_exit_32,
    __NR_seccomp_sigreturn_32,
    0, /* null terminated */
};
#endif
```

mode1_syscalls
= read, write, exit, sigreturn 시스템 콜의 번호를 저장하고 있는 변수
-> 애플리케이션의 호환 모드에 따라서 각 비트에 맞는 시스템 콜 번호를 저장

```
static void __secure_computing_strict(int this_syscall) {
  const int *allowed_syscalls = mode1_syscalls;
#ifdef CONFIG_COMPAT
  if (in_compat_syscall()) allowed_syscalls = get_compat_mode1_syscalls();
#endif
  do {
    if (*allowed_syscalls == this_syscall) return;
  } while (*++allowed_syscalls != -1);
#ifdef SECCOMP_DEBUG
  dump_stack();
#endif
  seccomp_log(this_syscall, SIGKILL, SECCOMP_RET_KILL_THREAD, true);
  do_exit(SIGKILL);
}
```
이후 애플리케이션에서 시스템 콜이 호출되면
__secure_computing 함수에 진입하여 
전달된 시스템콜 번호가 mode1_syscalls에 정의된 번호와 일치하는지 검사하고
-> 일치하지 않는다면 SIGKILL 시그널을 전달하고 SECCOMP_RET_KILL을 반환

## FILTER_MODE
= 원하는 시스템 콜의 호출을 허용하거나 거부 가능
- 라이브러리 함수를 이용한 방법
- 필터링에 주로 쓰이는 Berkeley Packet Filter (BPF) 문법을 통해 적용하는 방법

`apt install libseccomp-dev libseccomp2 seccomp`
-> seccomp 설치 명령어


